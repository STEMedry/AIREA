<!DOCTYPE html>
<html>
<head>
<title>Drone Camera Angle of View (AOV) Simulation</title>
<style>
    body {
        margin: 0;
        overflow: hidden;
        -webkit-user-select: none;
        -ms-user-select: none;
        user-select: none;
        font-family: Arial, sans-serif;
    }
    
    canvas { display: block; }
    
    #title {
        position: fixed;
        top: 5px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px 20px;
        border-radius: 5px;
        z-index: 1001;
        width: 90%;
        max-width: 600px;
        text-align: center;
    }
    
    #title h1 {
        margin: 0;
        font-size: 32px;
    }
    
    /* Style for Language Toggle and Start Tutorial Buttons */
    #languageToggle, #startTutorial {
      margin-bottom: 10px;
      padding: 5px 10px;
      font-size: 14px;
      cursor: pointer;
      background: #4CAF50;
      border: none;
      color: white;
      border-radius: 3px;
      transition: background 0.3s;
    }
    
    #languageToggle:hover, #languageToggle:focus,
    #startTutorial:hover, #startTutorial:focus {
        background: #45a049;
    }
    
    /* Controls Panel Styling */
    #controls {
        font-size: 1rem;
        position: fixed;
        top: 10px;
        left: 10px;
        background: rgba(0,0,0,0.7);
        color: white;
        padding: 10px;
        border-radius: 5px;
        z-index: 1000;
        width: 220px;
        box-sizing: border-box;
    }
    
    #controls button {
        display: block;
        width: 100%;
        margin: 5px 0;
        padding: 8px;
        background: #4CAF50;
        border: none;
        color: white;
        cursor: pointer;
        border-radius: 3px;
    }
    
    #controls button:hover {
        background: #45a049;
    }
    
    /* Calculation Controls Panel Styling */
    #additionalControls {
        position: fixed;
        background: rgba(0,0,0,0.7);
        color: white;
        padding: 10px;
        border-radius: 5px;
        width: 280px;
        box-sizing: border-box;
        overflow-y: visible;
        -webkit-overflow-scrolling: touch;
        top: 10px;
        right: 10px;
        max-height: calc(100vh - 20px);
        font-size: 14px;
    }
    
    #additionalControls h3 {
        font-size: 24px;
        margin: 0px 0 5px;
    }
    
    #additionalControls label {
        display: block;
        margin-top: 5px;
    }
    
    #additionalControls input[type="range"] {
        width: 90%;
        height: 10px;
        padding: 7.5px;
        margin: 2px 0 8px;
        font-size: 12px;
    }
    
    #additionalControls button {
        width: 100%;
        padding: 10px;
        margin: 5px 0;
        font-size: 14px;
    }
    
    #additionalControls p {
        margin: 5px 0;
    }
    
    hr {
        border: none;
        border-bottom: 1px solid #555;
        margin: 15px 0;
    }
    
    /* Responsive adjustments */
    @media (max-width: 768px) {
        #additionalControls {
            width: 45%;
            max-width: none;
            font-size: 12px;
            top: 50px;
            right: 2.5%;
        }
    
        #additionalControls h3 {
            font-size: 14px;
        }
    
        #additionalControls input[type="range"],
        #additionalControls button {
            font-size: 12px;
            padding: 5px;
            height: 22.5px;
        }
    }
    
    button {
        background: #4CAF50;
        color: white;
        cursor: pointer;
        font-weight: bold;
        transition: background 0.3s;
    }
    
    button:hover, button:focus {
        background: #45a049;
    }
    
    button:active {
        background: #3d8b40;
    }
    
    label {
        display: block;
        margin-top: 10px;
        font-weight: bold;
    }
    
    h3 {
        margin-top: 15px;
        margin-bottom: 5px;
        border-bottom: 1px solid #555;
        padding-bottom: 5px;
    }
    
    /* Improved touch targets for range inputs */
    input[type="range"] {
        -webkit-appearance: none;
        width: 100%;
        height: 22.5px;
        background: #d3d3d3;
        outline: none;
        opacity: 0.7;
        transition: opacity 0.2s;
        border-radius: 12px;
        margin: 8px 0;
    }
    
    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 22.5px;
        height: 22.5px;
        background: #4CAF50;
        cursor: pointer;
        border-radius: 50%;
    }
    
    input[type="range"]::-moz-range-thumb {
        width: 52.5px;
        height: 52.5px;
        background: #4CAF50;
        cursor: pointer;
        border-radius: 50%;
    }
    
    /* View control buttons */
    #viewControls {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: center;
        max-width: 90%;
    }
    
    .viewButton {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: rgba(0,0,0,0.7);
        color: white;
        border: none;
        font-size: 20px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    /* Aspect ratio buttons */
    .aspectRatioButtons {
        display: flex;
        justify-content: space-between;
        margin-bottom: 10px;
    }
    
    #controls .aspectRatioButtons button,
    #additionalControls .aspectRatioButtons button {
        flex: 1;
        margin: 0 5px;
        padding: 5px;
        font-size: 13px;
        background-color: #4CAF50;
        color: white;
        border: none;
        cursor: pointer;
        transition: background-color 0.3s;
    }
    
    #controls .aspectRatioButtons button:hover,
    #additionalControls .aspectRatioButtons button:hover {
        background-color: #45a049;
    }
    
    #controls .aspectRatioButtons button.active,
    #additionalControls .aspectRatioButtons button.active {
        background-color: #FFA500;
    }
    
    .toggle-building {
        background-color: #4CAF50;
        font-size: 14px; 
        color: white;
        cursor: pointer;
        transition: background-color 0.3s;
        margin-top: 2px;
        width: 100%;
    }
    
    .toggle-building.active {
        background-color: #FFA500;
    }
    
    /* Tutorial Overlay Styles */
    #tutorialOverlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.8);
        z-index: 2000;
        justify-content: center;
        align-items: center;
    }
    
    #tutorialContent {
        background-color: #fff;
        color: #000;
        padding: 20px;
        border-radius: 8px;
        width: 80%;
        max-width: 600px;
        position: relative;
        box-sizing: border-box;
    }
    
    #tutorialContent h2 {
        margin-top: 0;
    }
    
    #tutorialContent p {
        margin: 10px 0;
    }
    
    #tutorialContent .step {
        display: none;
    }
    
    #tutorialContent .step.active {
        display: block;
    }
    
    #tutorialOverlay .closeTutorial {
        position: absolute;
        top: 10px;
        right: 15px;
        font-size: 20px;
        cursor: pointer;
        background: none;
        border: none;
    }
    
    #tutorialNavigation {
        display: flex;
        justify-content: space-between;
        margin-top: 20px;
    }
    
    #tutorialNavigation button {
        padding: 10px 20px;
        background-color: #4CAF50;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
    }
    
    #tutorialNavigation button:hover {
        background-color: #45a049;
    }
    
    /* Highlighting Elements During Tutorial */
    .highlight {
        position: absolute;
        border: 3px solid #FFA500;
        border-radius: 5px;
        z-index: 2500;
        pointer-events: none;
        box-sizing: border-box;
    }
    
    #highlightBox {
        position: fixed;
        border: 3px solid #FFA500;
        border-radius: 5px;
        z-index: 2500;
        pointer-events: none;
        box-sizing: border-box;
        display: none;
        transition: all 0.3s ease;
        background: transparent;
    }
    
    #tutorialOverlay.active {
        background-color: rgba(0, 0, 0, 0.8);
    }
    
    /* Styles for Calculate AOV Results */
    #calc1Results .aovRow {
        display: flex;
        justify-content: space-between;
        margin-bottom: 5px;
    }
    
    #calc1Results .labels span, 
    #calc1Results .values span {
        flex: 2;
        text-align: center;
        font-size: 15px;
    }
    
    @media (max-width: 768px) {
        #calc1Results .labels span, 
        #calc1Results .values span {
            font-size: 12px;
        }
    }
    
    @media (max-width: 768px) {
        #tutorialContent {
            width: 90%;
        }
    }
    
    /* New Styles for Calculate Altitude Results */
    #calc2Results {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 10px;
    }
    
    #calc2Results label {
        flex: 1;
        font-size: 14px;
    }
    
    #calc2Results span {
        flex: 1;
        text-align: right;
        font-size: 15px;
    }
    
    @media (max-width: 768px) {
        #calc2Results label,
        #calc2Results span {
            font-size: 12px;
        }
    }
    
</style>
</head>
<body>
    <!-- Title -->
    <div id="title">
        <h1 data-i18n="Dronography AOV Simulation" data-i18n-zh="航拍視角模擬">Dronography AOV Simulation</h1>
    </div>
    
    <!-- Controls -->
    <div id="controls">
        <!-- Language Toggle Button -->
        <button id="languageToggle">繁體中文</button>
        <!-- Start Tutorial Button -->
        <button id="startTutorial" data-i18n="Start Tutorial" data-i18n-zh="開始教程">Start Tutorial</button>
    
        <h2 data-i18n="1. Calculate Area" data-i18n-zh="1. 計算面積">1. Calculate Area</h2>
        
        <!-- New Drone Altitude Slider added above Horizontal AOV -->
        <div>
            <label for="droneAltitudeSlider">
                <span data-i18n="Drone Altitude:" data-i18n-zh="無人機高度：">Drone Altitude:</span>
                <span id="droneAltitudeValue">0</span> m
            </label>
            <input type="range" id="droneAltitudeSlider" min="0" max="500" value="0">
        </div>
    
        <h3 data-i18n="Aspect Ratio" data-i18n-zh="畫幅比例">Aspect Ratio</h3>
        <div class="aspectRatioButtons">
            <button class="aspectRatioBtn" data-ratio="1.5" data-i18n="3:2" data-i18n-zh="3:2">3:2</button>
            <button class="aspectRatioBtn" data-ratio="1.333" data-i18n="4:3" data-i18n-zh="4:3">4:3</button>
            <button class="aspectRatioBtn" data-ratio="1.778" data-i18n="16:9" data-i18n-zh="16:9">16:9</button>
        </div>
        <div>
            <label for="aov">
                <span data-i18n="Horizontal AOV:" data-i18n-zh="水平視角:">Horizontal AOV:</span>
                <span id="aovValue">70</span> °
            </label>
            <input type="range" id="aov" min="30" max="120" value="70">
        </div>
    
        <div id="verticalDiagonalAOV">
            <label>
                <span data-i18n="Vertical AOV:" data-i18n-zh="垂直視角:">Vertical AOV:</span>
                <span id="vaovValue">0.0</span> °
            </label>
            <label>
                <span data-i18n="Diagonal AOV:" data-i18n-zh="對角線視角:">Diagonal AOV:</span>
                <span id="daovValue">0.0</span> °
            </label>
        </div>
    
        <div id="altitudeFOVMeasurements">
            <label>
                <span data-i18n="Altitude:" data-i18n-zh="高度:">Altitude:</span>
                <span id="altitudeValue">0</span> m
            </label>
            <label>
                <span data-i18n="FOV Width:" data-i18n-zh="視野寬度:">FOV Width:</span>
                <span id="widthValue">0</span> m
            </label>
            <label>
                <span data-i18n="FOV Height:" data-i18n-zh="視野高度:">FOV Height:</span>
                <span id="heightValue">0</span> m
            </label>
            <label>
                <span data-i18n="Area Captured:" data-i18n-zh="捕捉面積:">Area Captured:</span>
                <span id="areaValue">0</span> m²
            </label>
        </div>
    
        <hr>
    
        <!-- Toggle Buttons -->
        <div>
            <button id="toggleSchoolBuilding" class="toggle-building">
                <span data-i18n="School Building" data-i18n-zh="學校建築">School Building</span>
            </button>
        </div>
        <div>
            <button id="toggleTridentBlocks" class="toggle-building">
                <span data-i18n="Trident Blocks" data-i18n-zh="Y-型大廈">Trident Blocks</span>
            </button>
        </div>
        <div>
            <button id="toggleBankTower" class="toggle-building">
                <span data-i18n="Bank Tower" data-i18n-zh="銀行大廈">Bank Tower</span>
            </button>
        </div>
    </div>
    
    <!-- Calculation Controls Panel -->
    <div id="additionalControls">
        <h3 data-i18n="2. Calculate AOV" data-i18n-zh="2. 計算視角">2. Calculate AOV</h3>
        <div class="aspectRatioButtons">
            <button class="aspectRatioBtn" data-ratio="1.5" data-i18n="3:2" data-i18n-zh="3:2">3:2</button>
            <button class="aspectRatioBtn" data-ratio="1.333" data-i18n="4:3" data-i18n-zh="4:3">4:3</button>
            <button class="aspectRatioBtn" data-ratio="1.778" data-i18n="16:9" data-i18n-zh="16:9">16:9</button>
        </div>
        <div>
            <label for="calc1Altitude">
                <span data-i18n="Altitude:" data-i18n-zh="高度：">Altitude:</span>
                <span id="calc1AltitudeValue">0</span> m
            </label>
            <input type="range" id="calc1Altitude" min="0" max="500" value="0">
        </div>
        <div>
            <label for="calc1FOVWidth">
                <span data-i18n="FOV Width:" data-i18n-zh="視角寬度：">FOV Width:</span>
                <span id="calc1FOVWidthValue">0</span> m
            </label>
            <input type="range" id="calc1FOVWidth" min="0" max="1732" value="0">
        </div>
        <button id="calc1Button">
            <span data-i18n="Calculate AOV" data-i18n-zh="計算視角">Calculate AOV</span>
        </button>
    
    <div id="calc1Results">
        <!-- First Row: Labels -->
        <div class="aovRow labels">
            <span data-i18n="Horizontal AOV:" data-i18n-zh="水平視角：">Horizontal AOV:</span>
            <span data-i18n="Vertical AOV:" data-i18n-zh="垂直視角：">Vertical AOV:</span>
            <span data-i18n="Diagonal AOV:" data-i18n-zh="對角視角：">Diagonal AOV:</span>
        </div>
        <!-- Second Row: Values -->
        <div class="aovRow values">
            <span id="calc1HorizontalAOV">0.0</span>°
            <span id="calc1VerticalAOV">0.0</span>°
            <span id="calc1DiagonalAOV">0.0</span>°
        </div>
    </div>
    
        <hr>
    
        <h3 data-i18n="3. Calculate Altitude" data-i18n-zh="3. 計算高度">3. Calculate Altitude</h3>
        <div class="aspectRatioButtons">
            <button class="aspectRatioBtn" data-ratio="1.5" data-i18n="3:2" data-i18n-zh="3:2">3:2</button>
            <button class="aspectRatioBtn" data-ratio="1.333" data-i18n="4:3" data-i18n-zh="4:3">4:3</button>
            <button class="aspectRatioBtn" data-ratio="1.778" data-i18n="16:9" data-i18n-zh="16:9">16:9</button>
        </div>
    
        <div>
            <label for="calc2DiagonalAOV">
                <span data-i18n="Diagonal AOV:" data-i18n-zh="對角線視角：">Diagonal AOV:</span>
                <span id="calc2DiagonalAOVValue">0</span> °
            </label>
            <input type="range" id="calc2DiagonalAOV" min="0" max="128" value="0">
        </div>
    
        <div>
            <label for="calc2FOVWidth">
                <span data-i18n="FOV Width:" data-i18n-zh="視角寬度：">FOV Width:</span>
                <span id="calc2FOVWidthValue">0</span> m
            </label>
            <input type="range" id="calc2FOVWidth" min="0" max="1732" value="0">
        </div>
    
        <button id="calc2Button">
            <span data-i18n="Calculate Altitude" data-i18n-zh="計算高度">Calculate Altitude</span>
        </button>
    
        <div id="calc2Results">
            <label data-i18n="Required Altitude:" data-i18n-zh="所需高度：">Required Altitude:</label>
            <span id="calc2Altitude">0.0</span> m
        </div>
    </div>
    
    <!-- View Control Buttons -->
    <div id="viewControls">
        <button class="viewButton" id="tiltUp" aria-label="Tilt Up">↑</button>
        <button class="viewButton" id="tiltDown" aria-label="Tilt Down">↓</button>
        <button class="viewButton" id="rotateLeft" aria-label="Rotate Left">←</button>
        <button class="viewButton" id="rotateRight" aria-label="Rotate Right">→</button>
        <button class="viewButton" id="zoomIn" aria-label="Zoom In">+</button>
        <button class="viewButton" id="zoomOut" aria-label="Zoom Out">-</button>
        <button class="viewButton" id="homeView" aria-label="Home View">⌂</button>
        <button class="viewButton" id="moveUp" aria-label="Move Up">▲</button>
        <button class="viewButton" id="moveDown" aria-label="Move Down">▼</button>
        <button class="viewButton" id="moveForward" aria-label="Move Forward">↥</button>
        <button class="viewButton" id="moveBackward" aria-label="Move Backward">↧</button>
    </div>
    
    <!-- Tutorial Overlay -->
    <div id="tutorialOverlay">
        <div id="tutorialContent">
            <button class="closeTutorial" aria-label="Close Tutorial">×</button>
            <!-- Step 1 -->
            <div class="step active" data-step="1">
                <h2 data-i18n="Welcome to the Tutorial" data-i18n-zh="歡迎來到教程">Welcome to the Tutorial</h2>
                <p data-i18n="This tutorial will guide you through the various features of the Dronography AOV Simulation. Let's get started!" data-i18n-zh="本教程將引導您了解航拍視角模擬的各種功能。讓我們開始吧！">This tutorial will guide you through the various features of the Dronography AOV Simulation. Let's get started!</p>
            </div>
            <!-- Step 2: Aspect Ratio -->
            <div class="step" data-step="2">
                <h2 data-i18n="Aspect Ratio Selection" data-i18n-zh="畫幅比例選擇">Aspect Ratio Selection</h2>
                <p data-i18n="Use the Aspect Ratio buttons to select the desired aspect ratio. This changes how the camera view is proportioned." data-i18n-zh="使用畫幅比例按鈕選擇所需的畫幅比例。這將改變相機視圖的比例。">Use the Aspect Ratio buttons to select the desired aspect ratio. This changes how the camera view is proportioned.</p>
                <p data-i18n="Available options: 3:2, 4:3, 16:9." data-i18n-zh="可用選項：3:2，4:3，16:9。">Available options: 3:2, 4:3, 16:9.</p>
            </div>
            <!-- Step 3: Adjusting Horizontal AOV -->
            <div class="step" data-step="3">
                <h2 data-i18n="Adjusting Horizontal AOV" data-i18n-zh="調整水平視角">Adjusting Horizontal AOV</h2>
                <p data-i18n="The Horizontal AOV slider allows you to adjust the horizontal angle of view of the drone's camera. Drag the slider to increase or decrease the angle." data-i18n-zh="水平視角滑桿允許您調整無人機相機的水平視角。拖動滑桿以增加或減少角度。">The Horizontal AOV slider allows you to adjust the horizontal angle of view of the drone's camera. Drag the slider to increase or decrease the angle.</p>
                <p data-i18n="Current AOV value is displayed next to the slider." data-i18n-zh="當前視角值顯示在滑桿旁邊。">Current AOV value is displayed next to the slider.</p>
            </div>
            <!-- Step 4: Understanding Vertical and Diagonal AOV -->
            <div class="step" data-step="4">
                <h2 data-i18n="Vertical and Diagonal AOV" data-i18n-zh="垂直與對角視角">Vertical and Diagonal AOV</h2>
                <p data-i18n="Based on the Horizontal AOV and selected Aspect Ratio, the simulation calculates the Vertical and Diagonal AOV automatically." data-i18n-zh="根據水平視角和選定的畫幅比例，模擬會自動計算垂直和對角視角。">Based on the Horizontal AOV and selected Aspect Ratio, the simulation calculates the Vertical and Diagonal AOV automatically.</p>
                <p data-i18n="These values help in understanding the overall field of view." data-i18n-zh="這些值有助於理解整體視野。">These values help in understanding the overall field of view.</p>
            </div>
            <!-- Step 5: Altitude and FOV Measurements -->
            <div class="step" data-step="5">
                <h2 data-i18n="Altitude and FOV Measurements" data-i18n-zh="高度與視野測量">Altitude and FOV Measurements</h2>
                <p data-i18n="The simulation displays the drone's altitude, the width and height of the field of view (FOV), and the area captured. These metrics update in real-time as you adjust settings." data-i18n-zh="模擬顯示無人機的高度、視野的寬度和高度以及所捕捉的面積。這些指標會隨著您調整設置而實時更新。">The simulation displays the drone's altitude, the width and height of the field of view (FOV), and the area captured. These metrics update in real-time as you adjust settings.</p>
            </div>
            <!-- Step 6: Toggling Buildings -->
            <div class="step" data-step="6">
                <h2 data-i18n="Toggling Buildings" data-i18n-zh="切換建築物">Toggling Buildings</h2>
                <p data-i18n="Use the toggle buttons to show or hide different buildings in the simulation. This helps in visualizing how buildings affect the camera's AOV." data-i18n-zh="使用切換按鈕來顯示或隱藏模擬中的不同建築物。這有助於可視化建築物如何影響相機的視角。">Use the toggle buttons to show or hide different buildings in the simulation. This helps in visualizing how buildings affect the camera's AOV.</p>
            </div>
            <!-- Step 7: Calculation Controls -->
            <div class="step" data-step="7">
                <h2 data-i18n="Calculation Controls" data-i18n-zh="計算控制">Calculation Controls</h2>
                <p data-i18n="In the Calculation Controls panel, you can perform specific calculations related to AOV and altitude. Adjust the sliders and click the corresponding buttons to compute values." data-i18n-zh="在計算控制面板中，您可以執行與視角和高度相關的特定計算。調整滑桿並點擊相應的按鈕來計算值。">In the Calculation Controls panel, you can perform specific calculations related to AOV and altitude. Adjust the sliders and click the corresponding buttons to compute values.</p>
            </div>
            <!-- Step 8: View Controls -->
            <div class="step" data-step="8">
                <h2 data-i18n="View Controls" data-i18n-zh="視圖控制">View Controls</h2>
                <p data-i18n="Use the View Control buttons at the bottom of the screen to manipulate the camera view. You can tilt, rotate, zoom, and move the camera to better observe the simulation." data-i18n-zh="使用螢幕底部的視圖控制按鈕來操控相機視圖。您可以傾斜、旋轉、縮放和移動相機，以更好地觀察模擬。">Use the View Control buttons at the bottom of the screen to manipulate the camera view. You can tilt, rotate, zoom, and move the camera to better observe the simulation.</p>
            </div>
            <!-- Step 9: Language Toggle -->
            <div class="step" data-step="9">
                <h2 data-i18n="Language Toggle" data-i18n-zh="語言切換">Language Toggle</h2>
                <p data-i18n="Click the Language Toggle button at the top to switch between English and Traditional Chinese. This feature helps cater to a diverse range of users." data-i18n-zh="點擊頂部的語言切換按鈕在英文和繁體中文之間切換。此功能有助於滿足各種用戶的需求。">Click the Language Toggle button at the top to switch between English and Traditional Chinese. This feature helps cater to a diverse range of users.</p>
            </div>
            <!-- Step 10: Conclusion -->
            <div class="step" data-step="10">
                <h2 data-i18n="Tutorial Complete" data-i18n-zh="教程完成">Tutorial Complete</h2>
                <p data-i18n="You are now ready to explore the Dronography AOV Simulation. Experiment with different settings to understand how they affect the camera's field of view and the area captured." data-i18n-zh="您現在可以開始探索航拍視角模擬。嘗試不同的設置以了解它們如何影響相機的視野和所捕捉的面積。">You are now ready to explore the Dronography AOV Simulation. Experiment with different settings to understand how they affect the camera's field of view and the area captured.</p>
            </div>
            <!-- Navigation Buttons -->
            <div id="tutorialNavigation">
                <button id="prevStep" data-i18n="Previous" data-i18n-zh="上一頁">Previous</button>
                <button id="nextStep" data-i18n="Next" data-i18n-zh="下一頁">Next</button>
            </div>
        </div>
    </div>
    
    <!-- Highlight Box -->
    <div id="highlightBox" class="highlight" style="display:none;"></div>
    
    <!-- THREE.js Library (Single import only) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    
    // Global Variables
    let scene, camera, renderer, drone, fovArea;
    let isDragging = false;
    let dragStartPosition = { x: 0, y: 0 };
    let cameraAngle = Math.PI / 2;
    let cameraTilt = 0.5;
    let cameraDistance = 100;
    let draggedBuilding = null;
    let buildingDragStartX = 0;
    let mouseStartX = 0;
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    
    let verticalLine, fovLines, diagonals, propellers = [], blinkingLights = [];
    let blinkState = true;
    let lastBlinkTime = 0;
    const BLINK_INTERVAL = 500;
    let cornerLabels = [];
    let dimensionLabels = [];
    let centerLabel = null;
    
    let schoolBuilding;
    let bankTower;
    let tridentBlocks;
    
    const warnSound = new Audio('warn2.mp3');
    warnSound.preload = 'auto';
    
    function playWarnSound() {
        warnSound.currentTime = 0;
        warnSound.play().catch(function(error) {
            console.error("Error playing warning sound:", error);
        });
    }
    
    function getMaxDiagonalAOV(aspectRatio) {
        const maxHorizontalAOV = 120;
        const horizontalAOVRad = THREE.MathUtils.degToRad(maxHorizontalAOV);
        const verticalAOVRad = 2 * Math.atan(Math.tan(horizontalAOVRad / 2) / aspectRatio);
        const diagonalTan = Math.sqrt(Math.pow(Math.tan(horizontalAOVRad / 2), 2) +
                                        Math.pow(Math.tan(verticalAOVRad / 2), 2));
        const diagonalAOVRad = 2 * Math.atan(diagonalTan);
        const diagonalAOV = THREE.MathUtils.radToDeg(diagonalAOVRad);
        return diagonalAOV;
    }
    
    let currentMaxDiagonalAOV = getMaxDiagonalAOV(1.5);
    
    function createDottedLine(points, color = 0x000000) {
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const material = new THREE.LineDashedMaterial({
            color: color,
            dashSize: 1,
            gapSize: 2,
        });
        const line = new THREE.Line(geometry, material);
        line.computeLineDistances();
        return line;
    }
    
    function createPropeller(color) {
        const geometry = new THREE.BoxGeometry(3, 0.2, 0.4);
        const material = new THREE.MeshBasicMaterial({ color: color });
        return new THREE.Mesh(geometry, material);
    }
    
    function createBlinkingLight() {
        const geometry = new THREE.SphereGeometry(0.3, 16, 16);
        const material = new THREE.MeshBasicMaterial({
            color: 0xffff00,
            transparent: true,
            opacity: 1
        });
        return new THREE.Mesh(geometry, material);
    }
    
    function createCornerLabel(text, position) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 256;
        canvas.height = 256;
    
        context.clearRect(0, 0, canvas.width, canvas.height);
        context.font = 'bold 30px Arial';
        context.fillStyle = '#00FF00';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(text, 128, 128);
    
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.position.copy(position);
        sprite.scale.set(30, 30, 1);
        return sprite;
    }
    
    function createDimensionLabel(text, position, scale) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 256;
        canvas.height = 256;
    
        context.clearRect(0, 0, canvas.width, canvas.height);
        context.font = 'bold 32px Arial';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.lineWidth = 2;
        context.strokeStyle = 'black';
        context.strokeText(text, 128, 128);
        context.fillStyle = 'white';
        context.fillText(text, 128, 128);
    
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        const spriteMaterial = new THREE.SpriteMaterial({
            map: texture,
            transparent: true
        });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.position.copy(position);
        sprite.scale.set(scale, scale, 1);
        return sprite;
    }
    
    function createCenterLabel(text, position) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 256;
        canvas.height = 256;
    
        context.clearRect(0, 0, canvas.width, canvas.height);
        context.font = 'bold 24px Arial';
        context.fillStyle = '#00FF00';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(text, 128, 128);
    
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.position.copy(position);
        sprite.scale.set(30, 30, 1);
        return sprite;
    }
    
    // Minimal implementations of missing functions
    function createSchoolBuilding() {
        const group = new THREE.Group();
        const geometry = new THREE.BoxGeometry(20, 20, 20);
        const material = new THREE.MeshPhongMaterial({ color: 0xffffff });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.y = 10;
        group.add(mesh);
        return group;
    }
    
    function createBankTower() {
        const group = new THREE.Group();
        const geometry = new THREE.BoxGeometry(20, 40, 20);
        const material = new THREE.MeshPhongMaterial({ color: 0xaaaaaa });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.y = 20;
        group.add(mesh);
        return group;
    }
    
    function createTridentBlocks() {
        const group = new THREE.Group();
        const geometry = new THREE.BoxGeometry(30, 30, 30);
        const material = new THREE.MeshPhongMaterial({ color: 0xcccccc });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.y = 15;
        group.add(mesh);
        return group;
    }
    
    function init() {
    
        initAspectRatioButtons();
    
        // Set initial aspect ratio
        document.querySelector('#controls .aspectRatioBtn[data-ratio="1.5"]').click();
    
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
    
        const gridHelper = new THREE.GridHelper(1000, 100);
        scene.add(gridHelper);
    
        const axesLength = 200;
        const axesGeometry = new THREE.BufferGeometry();
        const vertices = new Float32Array([
            -axesLength, 0, 0,
             axesLength, 0, 0,
             0, 0, -axesLength,
             0, 0, axesLength
        ]);
        axesGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        const axesMaterial = new THREE.LineBasicMaterial({ color: 0xFFFFFF });
        const axes = new THREE.LineSegments(axesGeometry, axesMaterial);
        scene.add(axes);
    
        const labelDirections = [
            { text: "REAR", position: new THREE.Vector3(0, 0, axesLength + 5) },
            { text: "FRONT", position: new THREE.Vector3(0, 0, -axesLength - 5) },
            { text: "LEFT", position: new THREE.Vector3(-axesLength - 5, 0, 0) },
            { text: "RIGHT", position: new THREE.Vector3(axesLength + 5, 0, 0) }
        ];
    
        labelDirections.forEach(label => {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 256;
    
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.font = 'bold 72px Arial';
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(label.text, 128, 128);
    
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.copy(label.position);
            sprite.scale.set(30, 30, 1);
            scene.add(sprite);
        });
    
        const droneGeometry = new THREE.BoxGeometry(4, 1, 4);
        const droneMaterial = new THREE.MeshBasicMaterial({
            color: 0x87CEFA,
            transparent: true,
            opacity: 0.5
        });
        drone = new THREE.Mesh(droneGeometry, droneMaterial);
        drone.position.y = 0;
        scene.add(drone);
    
        const edges = new THREE.EdgesGeometry(droneGeometry);
        const edgesMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 });
        const edgeLines = new THREE.LineSegments(edges, edgesMaterial);
        drone.add(edgeLines);
    
        const propellerPositions = [
            { x: 2.5, y: 0.5, z: 2.5, color: 0x00ff00, clockwise: false },
            { x: -2.5, y: 0.5, z: 2.5, color: 0x00ff00, clockwise: true },
            { x: 2.5, y: 0.5, z: -2.5, color: 0xff0000, clockwise: true },
            { x: -2.5, y: 0.5, z: -2.5, color: 0xff0000, clockwise: false }
        ];
    
        propellerPositions.forEach(pos => {
            const propeller = createPropeller(pos.color);
            propeller.position.set(pos.x, pos.y, pos.z);
            propeller.userData.clockwise = pos.clockwise;
            drone.add(propeller);
            propellers.push(propeller);
    
            const light = createBlinkingLight();
            light.position.set(pos.x, pos.y + 0.2, pos.z);
            drone.add(light);
            blinkingLights.push(light);
        });
    
        const fovGeometry = new THREE.PlaneGeometry(1, 1);
        const fovMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
        });
        fovArea = new THREE.Mesh(fovGeometry, fovMaterial);
        fovArea.rotation.x = -Math.PI / 2;
        scene.add(fovArea);
    
        verticalLine = new THREE.Group();
        fovLines = new THREE.Group();
        diagonals = new THREE.Group();
        scene.add(verticalLine);
        scene.add(fovLines);
        scene.add(diagonals);
    
        updateCamera();
    
        schoolBuilding = createSchoolBuilding();
        schoolBuilding.position.set(-50, 0, -20);
        schoolBuilding.visible = false;
        scene.add(schoolBuilding);
    
        bankTower = createBankTower();
        bankTower.position.set(50, 0, 10);
        bankTower.visible = false;
        scene.add(bankTower);
    
        tridentBlocks = createTridentBlocks();
        tridentBlocks.visible = false;
        scene.add(tridentBlocks);
    
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
    
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 50, 50);
        scene.add(directionalLight);
    
        window.addEventListener('resize', onWindowResize, false);
        renderer.domElement.addEventListener('mousedown', onMouseDown, false);
        renderer.domElement.addEventListener('mousemove', onMouseMove, false);
        renderer.domElement.addEventListener('mouseup', onMouseUp, false);
        renderer.domElement.addEventListener('wheel', onWheel, false);
        renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault(), false);
    
        function initBuildingButtons() {
            document.getElementById('toggleSchoolBuilding').classList.toggle('active', schoolBuilding.visible);
            document.getElementById('toggleBankTower').classList.toggle('active', bankTower.visible);
            document.getElementById('toggleTridentBlocks').classList.toggle('active', tridentBlocks.visible);
        }
    
        initBuildingButtons();
    
        function initAspectRatioButtons() {
            const aspectButtonsControls = document.querySelectorAll('#controls .aspectRatioBtn');
            const aspectButtonsAdditional = document.querySelectorAll('#additionalControls .aspectRatioBtn');
    
            const allAspectButtons = [...aspectButtonsControls, ...aspectButtonsAdditional];
    
            allAspectButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const aspectRatio = parseFloat(this.getAttribute('data-ratio'));
                    currentMaxDiagonalAOV = getMaxDiagonalAOV(aspectRatio);
    
                    allAspectButtons.forEach(btn => {
                        btn.classList.remove('active');
                    });
    
                    const activeButtons = allAspectButtons.filter(btn => parseFloat(btn.getAttribute('data-ratio')) === aspectRatio);
                    activeButtons.forEach(btn => {
                        btn.classList.add('active');
                    });
    
                    updateFOV();
                });
            });
        }
    
        document.getElementById('aov').addEventListener('input', updateFOV);
    
        // New Drone Altitude Slider Listener
        document.getElementById('droneAltitudeSlider').addEventListener('input', function() {
            const altitude = parseFloat(this.value);
            drone.position.y = altitude;
            document.getElementById('droneAltitudeValue').textContent = altitude.toFixed(1);
            updateFOV();
            updateCamera();
        });
    
        document.getElementById('calc1Button').addEventListener('click', calculateAOV);
        document.getElementById('calc2Button').addEventListener('click', calculateAltitude);
    
        document.getElementById('calc1Altitude').addEventListener('input', function() {
            document.getElementById('calc1AltitudeValue').textContent = this.value;
        });
        document.getElementById('calc1FOVWidth').addEventListener('input', function() {
            document.getElementById('calc1FOVWidthValue').textContent = this.value;
        });
        document.getElementById('calc2DiagonalAOV').addEventListener('input', function() {
            document.getElementById('calc2DiagonalAOVValue').textContent = this.value;
        });
        document.getElementById('calc2FOVWidth').addEventListener('input', function() {
            document.getElementById('calc2FOVWidthValue').textContent = this.value;
        });
    
        document.querySelector('.aspectRatioBtn[data-ratio="1.5"]').click();
    
        updateFOV();
    }
    
    function toggleBuilding(buildingType) {
        let building, button;
    
        switch(buildingType) {
            case 'school':
                building = schoolBuilding;
                button = document.getElementById('toggleSchoolBuilding');
                break;
            case 'bank':
                building = bankTower;
                button = document.getElementById('toggleBankTower');
                break;
            case 'trident':
                building = tridentBlocks;
                button = document.getElementById('toggleTridentBlocks');
                break;
        }
    
        if (building && button) {
            const isActive = button.classList.toggle('active');
            building.visible = isActive;
        }
    }
    
    document.getElementById('toggleSchoolBuilding').addEventListener('click', () => toggleBuilding('school'));
    document.getElementById('toggleBankTower').addEventListener('click', () => toggleBuilding('bank'));
    document.getElementById('toggleTridentBlocks').addEventListener('click', () => toggleBuilding('trident'));
    
    function updateCamera() {
        const x = cameraDistance * Math.cos(cameraAngle) * Math.cos(cameraTilt);
        const y = cameraDistance * Math.sin(cameraTilt);
        const z = cameraDistance * Math.sin(cameraAngle) * Math.cos(cameraTilt);
        camera.position.set(
            drone.position.x + x,
            drone.position.y + y,
            drone.position.z + z
        );
        camera.lookAt(drone.position);
    }
    
    function updateBlinkingLights() {
        const currentTime = Date.now();
        if (currentTime - lastBlinkTime > BLINK_INTERVAL) {
            blinkState = !blinkState;
            blinkingLights.forEach(light => {
                light.material.opacity = blinkState ? 1 : 0.3;
            });
            lastBlinkTime = currentTime;
        }
    }
    
    function onWheel(event) {
        event.preventDefault();
        cameraDistance += event.deltaY * 0.1;
        cameraDistance = Math.max(10, Math.min(1000, cameraDistance));
        updateCamera();
    }
    
    function onMouseDown(event) {
        isDragging = true;
        dragStartPosition.x = event.clientX;
        dragStartPosition.y = event.clientY;
        const button = event.button;
    
        if (button === 0) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
    
            const intersectsSchool = schoolBuilding.visible ? raycaster.intersectObject(schoolBuilding, true) : [];
            const intersectsBank = bankTower.visible ? raycaster.intersectObject(bankTower, true) : [];
            const intersectsTrident = tridentBlocks.visible ? raycaster.intersectObject(tridentBlocks, true) : [];
    
            if (intersectsSchool.length > 0) {
                draggedBuilding = 'school';
                buildingDragStartX = schoolBuilding.position.x;
                mouseStartX = event.clientX;
            } else if (intersectsBank.length > 0) {
                draggedBuilding = 'bank';
                buildingDragStartX = bankTower.position.x;
                mouseStartX = event.clientX;
            } else if (intersectsTrident.length > 0) {
                draggedBuilding = 'trident';
                buildingDragStartX = tridentBlocks.position.x;
                mouseStartX = event.clientX;
            } else {
                draggedBuilding = null;
            }
        }
    }
    
    function onMouseMove(event) {
        if (isDragging) {
            const deltaX = event.clientX - dragStartPosition.x;
            const deltaY = event.clientY - dragStartPosition.y;
    
            if (draggedBuilding) {
                const movementX = (event.clientX - mouseStartX) * 0.5;
                if (draggedBuilding === 'school') {
                    schoolBuilding.position.x = buildingDragStartX + movementX;
                } else if (draggedBuilding === 'bank') {
                    bankTower.position.x = buildingDragStartX + movementX;
                } else if (draggedBuilding === 'trident') {
                    tridentBlocks.position.x = buildingDragStartX + movementX;
                }
            } else {
                if (event.buttons & 1) {
                    const newAltitude = parseFloat(drone.position.y) - deltaY * 0.5;
                    drone.position.y = Math.max(0, Math.min(500, newAltitude));
                    updateFOV();
                } else if (event.buttons & 2) {
                    if (event.shiftKey) {
                        drone.position.x += deltaX * 0.5;
                        drone.position.z += deltaY * 0.5;
                        updateFOV();
                    } else {
                        cameraAngle -= deltaX * 0.01;
                        cameraTilt += deltaY * 0.01;
                        cameraTilt = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraTilt));
                        updateCamera();
                    }
                }
            }
    
            dragStartPosition.x = event.clientX;
            dragStartPosition.y = event.clientY;
        }
    }
    
    function onMouseUp(event) {
        isDragging = false;
        draggedBuilding = null;
    }
    
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function calculateAOV() {
        const aspectRatio = parseFloat(document.querySelector('#additionalControls .aspectRatioBtn.active').getAttribute('data-ratio'));
        const altitude = parseFloat(document.getElementById('calc1Altitude').value);
        const fovWidth = parseFloat(document.getElementById('calc1FOVWidth').value);
    
        if (isNaN(aspectRatio) || isNaN(altitude) || isNaN(fovWidth)) {
            playWarnSound();
            alert(getTranslation("Please enter valid numerical values.", "請輸入有效的數值。"));
            return;
        }
    
        if (altitude <= 0 || fovWidth <= 0) {
            playWarnSound();
            alert(getTranslation("Altitude and FOV Width must be greater than zero.", "高度和視野寬度必須大於零。"));
            return;
        }
    
        if (altitude > 500) {
            playWarnSound();
            alert(getTranslation("Altitude exceeds the maximum allowed range of 500m.", "高度超過允許的最大範圍500米。"));
            return;
        }
    
        const horizontalAOVRad = 2 * Math.atan(fovWidth / (2 * altitude));
        const horizontalAOV = THREE.MathUtils.radToDeg(horizontalAOVRad);
    
        if (horizontalAOV < 30 || horizontalAOV > 120) {
            playWarnSound();
            alert(getTranslation("Calculated Horizontal AOV is out of the allowed range (30-120°).", "計算出的水平視角超出允許範圍（30-120°）。"));
            return;
        }
    
        const verticalAOVRad = 2 * Math.atan(Math.tan(horizontalAOVRad / 2) / aspectRatio);
        const verticalAOV = THREE.MathUtils.radToDeg(verticalAOVRad);
    
        const diagonalTan = Math.sqrt(Math.pow(Math.tan(horizontalAOVRad / 2), 2) + Math.pow(Math.tan(verticalAOVRad / 2), 2));
        const diagonalAOVRad = 2 * Math.atan(diagonalTan);
        const diagonalAOV = THREE.MathUtils.radToDeg(diagonalAOVRad);
    
        const maxDiagonalAOV = getMaxDiagonalAOV(aspectRatio);
    
        if (diagonalAOV > maxDiagonalAOV) {
            playWarnSound();
            alert(getTranslation(`Calculated Diagonal AOV (${diagonalAOV.toFixed(1)}°) exceeds the maximum allowed (${maxDiagonalAOV.toFixed(1)}°) for the selected aspect ratio.`, `計算出的對角視角（${diagonalAOV.toFixed(1)}°）超出所選畫幅比例允許的最大值（${maxDiagonalAOV.toFixed(1)}°）。`));
            return;
        }
    
        document.getElementById('calc1HorizontalAOV').textContent = horizontalAOV.toFixed(1);
        document.getElementById('calc1VerticalAOV').textContent = verticalAOV.toFixed(1);
        document.getElementById('calc1DiagonalAOV').textContent = diagonalAOV.toFixed(1);
    
        document.getElementById('aov').value = horizontalAOV.toFixed(1);
        document.getElementById('altitudeValue').textContent = altitude.toFixed(1);
        document.getElementById('widthValue').textContent = fovWidth.toFixed(1);
    
        drone.position.y = altitude;
        fovArea.scale.set(fovWidth, fovWidth / aspectRatio, 1);
    
        updateFOV();
    }
    
    function calculateAltitude() {
        const aspectRatio = parseFloat(document.querySelector('#additionalControls .aspectRatioBtn.active').getAttribute('data-ratio'));
        const diagonalAOVDegrees = parseFloat(document.getElementById('calc2DiagonalAOV').value);
        const fovWidth = parseFloat(document.getElementById('calc2FOVWidth').value);
    
        if (isNaN(aspectRatio) || isNaN(diagonalAOVDegrees) || isNaN(fovWidth)) {
            playWarnSound();
            alert(getTranslation("Please enter valid numerical values.", "請輸入有效的數值。"));
            return;
        }
    
        if (diagonalAOVDegrees <= 0 || fovWidth <= 0) {
            playWarnSound();
            alert(getTranslation("Diagonal AOV and FOV Width must be greater than zero.", "對角視角和視野寬度必須大於零。"));
            return;
        }
    
        const maxDiagonalAOV = getMaxDiagonalAOV(aspectRatio);
    
        if (diagonalAOVDegrees > maxDiagonalAOV) {
            playWarnSound();
            alert(getTranslation(`Input Diagonal AOV (${diagonalAOVDegrees.toFixed(1)}°) exceeds the maximum allowed (${maxDiagonalAOV.toFixed(1)}°) for the selected aspect ratio.`, `輸入的對角視角（${diagonalAOVDegrees.toFixed(1)}°）超出所選畫幅比例允許的最大值（${maxDiagonalAOV.toFixed(1)}°）。`));
            return;
        }
    
        const diagonalAOVRad = THREE.MathUtils.degToRad(diagonalAOVDegrees);
        const altitude = (fovWidth / 2) * Math.sqrt(1 + 1 / Math.pow(aspectRatio, 2)) / Math.tan(diagonalAOVRad / 2);
    
        if (altitude < 0 || altitude > 500) {
            playWarnSound();
            alert(getTranslation("Calculated altitude is out of the allowed range (0-500m).", "計算出的高度超出允許的範圍（0-500米）。"));
            return;
        }
    
        const horizontalAOVRad = 2 * Math.atan(fovWidth / (2 * altitude));
        const horizontalAOV = THREE.MathUtils.radToDeg(horizontalAOVRad);
    
        if (horizontalAOV < 30 || horizontalAOV > 120) {
            playWarnSound();
            alert(getTranslation("Calculated Horizontal AOV is out of the allowed range (30-120°).", "計算出的水平視角超出允許範圍（30-120°）。"));
            return;
        }
    
        const verticalAOVRad = 2 * Math.atan(Math.tan(horizontalAOVRad / 2) / aspectRatio);
        const verticalAOV = THREE.MathUtils.radToDeg(verticalAOVRad);
    
        const diagonalTan = Math.sqrt(Math.pow(Math.tan(horizontalAOVRad / 2), 2) + Math.pow(Math.tan(verticalAOVRad / 2), 2));
        const diagonalAOVCalcRad = 2 * Math.atan(diagonalTan);
        const diagonalAOVCalc = THREE.MathUtils.radToDeg(diagonalAOVCalcRad);
    
        document.getElementById('calc2Altitude').textContent = altitude.toFixed(1);
    
        document.getElementById('calc1Altitude').value = altitude.toFixed(1);
        document.getElementById('calc1AltitudeValue').textContent = altitude.toFixed(1);
        document.getElementById('calc1FOVWidth').value = fovWidth.toFixed(1);
        document.getElementById('calc1FOVWidthValue').textContent = fovWidth.toFixed(1);
        document.getElementById('calc1HorizontalAOV').textContent = horizontalAOV.toFixed(1);
        document.getElementById('calc1VerticalAOV').textContent = verticalAOV.toFixed(1);
        document.getElementById('calc1DiagonalAOV').textContent = diagonalAOVCalc.toFixed(1);
    
        document.getElementById('aov').value = horizontalAOV.toFixed(1);
        document.getElementById('altitudeValue').textContent = altitude.toFixed(1);
        document.getElementById('widthValue').textContent = fovWidth.toFixed(1);
    
        drone.position.y = altitude;
    
        fovArea.scale.set(fovWidth, fovWidth / aspectRatio, 1);
    
        updateFOV();
    }
    
    function updateFOV() {
        const altitude = drone.position.y;
        const aov = parseFloat(document.getElementById('aov').value);
        const aspectRatio = parseFloat(document.querySelector('#controls .aspectRatioBtn.active').getAttribute('data-ratio'));
    
        let width = 0;
        let height = 0;
        let area = 0;
        let verticalAOV = 0;
        let diagonalAOV = 0;
    
        if (altitude > 0) {
            width = 2 * altitude * Math.tan(THREE.MathUtils.degToRad(aov) / 2);
            height = width / aspectRatio;
            area = width * height;
    
            verticalAOV = 2 * THREE.MathUtils.radToDeg(Math.atan(Math.tan(THREE.MathUtils.degToRad(aov) / 2) / aspectRatio));
    
            const diagonalTan = Math.sqrt(Math.pow(Math.tan(THREE.MathUtils.degToRad(aov) / 2), 2) + Math.pow(Math.tan(THREE.MathUtils.degToRad(verticalAOV) / 2), 2));
            diagonalAOV = 2 * THREE.MathUtils.radToDeg(Math.atan(diagonalTan));
    
            if (diagonalAOV > currentMaxDiagonalAOV) {
                playWarnSound();
                alert(getTranslation(`Calculated Diagonal AOV (${diagonalAOV.toFixed(1)}°) exceeds the maximum allowed (${currentMaxDiagonalAOV.toFixed(1)}°) for the selected aspect ratio.`, `計算出的對角視角（${diagonalAOV.toFixed(1)}°）超出所選畫幅比例允許的最大值（${currentMaxDiagonalAOV.toFixed(1)}°）。`));
            }
        }
    
        fovArea.scale.set(width, height, 1);
        fovArea.position.copy(drone.position);
        fovArea.position.y = 0;
    
        verticalLine.clear();
        const centerPoint = new THREE.Vector3(drone.position.x, 0, drone.position.z);
        const verticalLineGeometry = createDottedLine([drone.position.clone(), centerPoint], 0xFFFFFF);
        verticalLine.add(verticalLineGeometry);
    
        fovLines.clear();
    
        const halfWidth = width / 2;
        const halfHeight = height / 2;
        const corners = [
            new THREE.Vector3(drone.position.x + halfWidth, 0, drone.position.z + halfHeight),
            new THREE.Vector3(drone.position.x - halfWidth, 0, drone.position.z + halfHeight),
            new THREE.Vector3(drone.position.x - halfWidth, 0, drone.position.z - halfHeight),
            new THREE.Vector3(drone.position.x + halfWidth, 0, drone.position.z - halfHeight)
        ];
    
        corners.forEach(corner => {
            const line = createDottedLine([drone.position.clone(), corner], 0xFFFFFF);
            fovLines.add(line);
        });
    
        diagonals.clear();
    
        if (altitude > 0) {
            const diagonalAC = createDottedLine([corners[0], corners[2]], 0xFFFF00);
            const diagonalBD = createDottedLine([corners[1], corners[3]], 0xFFFF00);
            diagonals.add(diagonalAC);
            diagonals.add(diagonalBD);
        }
    
        cornerLabels.forEach(label => scene.remove(label));
        cornerLabels = [];
    
        const labels = ['A', 'B', 'C', 'D'];
        corners.forEach((corner, index) => {
            const label = createCornerLabel(labels[index], corner);
            scene.add(label);
            cornerLabels.push(label);
        });
    
        dimensionLabels.forEach(label => scene.remove(label));
        dimensionLabels = [];
    
        if (altitude > 0) {
            const midpointAB = new THREE.Vector3(
                (corners[0].x + corners[1].x) / 2,
                0,
                (corners[0].z + corners[1].z) / 2
            );
            const midpointBC = new THREE.Vector3(
                (corners[1].x + corners[2].x) / 2,
                0,
                (corners[1].z + corners[2].z) / 2
            );
    
            const offsetDistance = -5;
            const directionAB = new THREE.Vector3(corners[1].x - corners[0].x, 0, corners[1].z - corners[0].z).normalize();
            const perpendicularAB = new THREE.Vector3(-directionAB.z, 0, directionAB.x);
            const directionBC = new THREE.Vector3(corners[2].x - corners[1].x, 0, corners[2].z - corners[1].z).normalize();
            const perpendicularBC = new THREE.Vector3(-directionBC.z, 0, directionBC.x);
    
            const offsetMidpointAB = midpointAB.clone().add(perpendicularAB.multiplyScalar(offsetDistance));
            const offsetMidpointBC = midpointBC.clone().add(perpendicularBC.multiplyScalar(offsetDistance));
    
            const baseAltitude = 100;
            const minScale = 20;
            const maxScale = 120;
            let scaleFactor = 20;
            if (altitude <= baseAltitude) {
                scaleFactor = minScale;
            } else if (altitude >= 500) {
                scaleFactor = maxScale;
            } else {
                scaleFactor = minScale + ((altitude - baseAltitude) / (500 - baseAltitude)) * (maxScale - minScale);
            }
    
            const abLength = Math.sqrt(Math.pow(corners[1].x - corners[0].x, 2) + Math.pow(corners[1].z - corners[0].z, 2));
            const abLabel = createDimensionLabel(`${getTranslation('AB:', 'AB：')} ${abLength.toFixed(1)}m`, offsetMidpointAB, scaleFactor);
            scene.add(abLabel);
            dimensionLabels.push(abLabel);
    
            const bcLength = Math.sqrt(Math.pow(corners[2].x - corners[1].x, 2) + Math.pow(corners[2].z - corners[1].z, 2));
            const bcLabel = createDimensionLabel(`${getTranslation('BC:', 'BC：')} ${bcLength.toFixed(1)}m`, offsetMidpointBC, scaleFactor);
            scene.add(bcLabel);
            dimensionLabels.push(bcLabel);
        }
    
        if (centerLabel) {
            scene.remove(centerLabel);
        }
    
        const centerPosition = new THREE.Vector3(drone.position.x, 0, drone.position.z);
        centerLabel = createCenterLabel('O', centerPosition);
        scene.add(centerLabel);
    
        document.getElementById('aovValue').textContent = aov.toFixed(1);
        document.getElementById('vaovValue').textContent = altitude > 0 ? verticalAOV.toFixed(1) : '0.0';
        document.getElementById('daovValue').textContent = altitude > 0 ? diagonalAOV.toFixed(1) : '0.0';
        document.getElementById('altitudeValue').textContent = altitude.toFixed(1);
        document.getElementById('widthValue').textContent = width.toFixed(1);
        document.getElementById('heightValue').textContent = height.toFixed(1);
        document.getElementById('areaValue').textContent = area.toFixed(1);
    }
    
    function animate() {
        requestAnimationFrame(animate);
    
        propellers.forEach(propeller => {
            propeller.rotation.y += propeller.userData.clockwise ? 0.3 : -0.3;
        });
    
        updateBlinkingLights();
    
        renderer.render(scene, camera);
    }
    
    init();
    animate();
    
    let isTouchMoving = false;
    
    document.body.addEventListener('touchstart', function(event) {
        isTouchMoving = false;
    }, { passive: false });
    
    document.body.addEventListener('touchmove', function(event) {
        isTouchMoving = true;
    }, { passive: false });
    
    document.body.addEventListener('touchend', function(event) {
        if (!isTouchMoving) {
            event.preventDefault();
        }
    }, { passive: false });
    
    const isiPad = /iPad/i.test(navigator.userAgent);
    
    function getTouchPos(touchEvent) {
        const rect = renderer.domElement.getBoundingClientRect();
        return {
            x: ((touchEvent.touches[0].clientX - rect.left) / rect.width) * 2 - 1,
            y: -((touchEvent.touches[0].clientY - rect.top) / rect.height) * 2 + 1
        };
    }
    
    let lastTouchX = null;
    let lastTouchY = null;
    let isPinching = false;
    let initialPinchDistance = 0;
    
    function getDistance(touch1, touch2) {
        const dx = touch2.clientX - touch1.clientX;
        const dy = touch2.clientY - touch1.clientY;
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    renderer.domElement.addEventListener('touchstart', function(event) {
        event.preventDefault();
    
        if (event.touches.length === 1) {
            lastTouchX = event.touches[0].clientX;
            lastTouchY = event.touches[0].clientY;
        } else if (event.touches.length === 2) {
            isPinching = true;
            initialPinchDistance = getDistance(event.touches[0], event.touches[1]);
        }
    }, { passive: false });
    
    renderer.domElement.addEventListener('touchmove', function(event) {
        event.preventDefault();
    
        if (event.touches.length === 1 && !isPinching) {
            const touch = event.touches[0];
            const deltaX = touch.clientX - lastTouchX;
            const deltaY = touch.clientY - lastTouchY;
            lastTouchX = touch.clientX;
            lastTouchY = touch.clientY;
    
            const threshold = 5;
    
            if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > threshold) {
                const rotationSpeed = 0.005;
                cameraAngle += deltaX * rotationSpeed;
                updateCamera();
            } else if (!isiPad && Math.abs(deltaY) > threshold) {
                const altitudeChange = -deltaY * 0.5;
                drone.position.y += altitudeChange;
                drone.position.y = Math.max(0, Math.min(500, drone.position.y));
                updateFOV();
                updateCamera();
            }
    
        } else if (event.touches.length === 2) {
            const currentDistance = getDistance(event.touches[0], event.touches[1]);
            const deltaDistance = currentDistance - initialPinchDistance;
            initialPinchDistance = currentDistance;
    
            const zoomSpeed = 0.1;
            cameraDistance -= deltaDistance * zoomSpeed;
            cameraDistance = Math.max(10, Math.min(1000, cameraDistance));
            updateCamera();
        }
    }, { passive: false });
    
    renderer.domElement.addEventListener('touchend', function(event) {
        event.preventDefault();
    
        if (event.touches.length < 2) {
            isPinching = false;
            initialPinchDistance = 0;
        }
    
        if (event.touches.length === 0) {
            lastTouchX = null;
            lastTouchY = null;
        }
    }, { passive: false });
    
    document.querySelectorAll('button').forEach(button => {
        button.addEventListener('touchstart', function(e) {
            e.preventDefault();
            this.click();
        });
    });
    
    let lastTouchEnd = 0;
    document.addEventListener('touchend', function(event) {
        const now = (new Date()).getTime();
        if (now - lastTouchEnd <= 300) {
            event.preventDefault();
        }
        lastTouchEnd = now;
    }, false);
    
    function tiltUp() {
        cameraTilt = Math.min(cameraTilt + 0.1, Math.PI / 2 - 0.1);
        updateCamera();
    }
    
    function tiltDown() {
        cameraTilt = Math.max(cameraTilt - 0.1, -Math.PI / 2 + 0.1);
        updateCamera();
    }
    
    function rotateLeft() {
        cameraAngle += 0.1;
        updateCamera();
    }
    
    function rotateRight() {
        cameraAngle -= 0.1;
        updateCamera();
    }
    
    function zoomIn() {
        cameraDistance = Math.max(cameraDistance - 2, 10);
        updateCamera();
    }
    
    function zoomOut() {
        cameraDistance = Math.min(cameraDistance + 2, 1000);
        updateCamera();
    }
    
    function resetView() {
        cameraAngle = Math.PI / 2;
        cameraTilt = 0.5;
        cameraDistance = 100;
    
        drone.position.set(0, 0, 0);
    
        updateFOV();
        updateCamera();
    
        document.getElementById('aov').value = 70;
        document.getElementById('aov').dispatchEvent(new Event('input'));
    }
    
    function moveUp() {
        drone.position.y = Math.min(500, drone.position.y + 1);
        updateFOV();
        updateCamera();
    }
    
    function moveDown() {
        drone.position.y = Math.max(0, drone.position.y - 1);
        updateFOV();
        updateCamera();
    }
    
    function moveForward() {
        const moveDistance = 1;
        drone.position.z -= moveDistance;
        updateFOV();
        updateCamera();
    }
    
    function moveBackward() {
        const moveDistance = 1;
        drone.position.z += moveDistance;
        updateFOV();
        updateCamera();
    }
    
    document.getElementById('tiltUp').addEventListener('click', tiltUp);
    document.getElementById('tiltDown').addEventListener('click', tiltDown);
    document.getElementById('rotateLeft').addEventListener('click', rotateLeft);
    document.getElementById('rotateRight').addEventListener('click', rotateRight);
    document.getElementById('zoomIn').addEventListener('click', zoomIn);
    document.getElementById('zoomOut').addEventListener('click', zoomOut);
    document.getElementById('homeView').addEventListener('click', resetView);
    document.getElementById('moveUp').addEventListener('click', moveUp);
    document.getElementById('moveDown').addEventListener('click', moveDown);
    document.getElementById('moveForward').addEventListener('click', moveForward);
    document.getElementById('moveBackward').addEventListener('click', moveBackward);
    
    const languageToggle = document.getElementById('languageToggle');
    const elements = document.querySelectorAll('[data-i18n], [data-i18n-zh]');
    
    languageToggle.addEventListener('click', () => {
        if (languageToggle.textContent === '繁體中文') {
            languageToggle.textContent = 'English';
            elements.forEach(element => {
                if (element.hasAttribute('data-i18n-zh')) {
                    element.textContent = element.getAttribute('data-i18n-zh');
                }
            });
        } else {
            languageToggle.textContent = '繁體中文';
            elements.forEach(element => {
                if (element.hasAttribute('data-i18n')) {
                    element.textContent = element.getAttribute('data-i18n');
                }
            });
        }
        updateTutorialTranslation();
    });
    
    function getTranslation(en, zh) {
        return languageToggle.textContent === '繁體中文' ? en : zh;
    }
    
    const startTutorialButton = document.getElementById('startTutorial');
    const tutorialOverlay = document.getElementById('tutorialOverlay');
    const closeTutorialButton = document.querySelector('.closeTutorial');
    const steps = document.querySelectorAll('#tutorialContent .step');
    const nextStepButton = document.getElementById('nextStep');
    const prevStepButton = document.getElementById('prevStep');
    let currentStep = 0;
    
    const highlightBox = document.getElementById('highlightBox');
    
    startTutorialButton.addEventListener('click', () => {
        currentStep = 0;
        showStep(currentStep);
        tutorialOverlay.style.display = 'flex';
        highlightCurrentStep();
    });
    
    closeTutorialButton.addEventListener('click', () => {
        tutorialOverlay.style.display = 'none';
        removeHighlight();
    });
    
    nextStepButton.addEventListener('click', () => {
        if (currentStep < steps.length - 1) {
            currentStep++;
            showStep(currentStep);
            highlightCurrentStep();
        } else {
            tutorialOverlay.style.display = 'none';
            removeHighlight();
        }
    });
    
    prevStepButton.addEventListener('click', () => {
        if (currentStep > 0) {
            currentStep--;
            showStep(currentStep);
            highlightCurrentStep();
        }
    });
    
    function showStep(index) {
        steps.forEach((step, i) => {
            step.classList.toggle('active', i === index);
        });
    
        prevStepButton.style.display = index === 0 ? 'none' : 'inline-block';
    
        if (index === steps.length - 1) {
            nextStepButton.setAttribute('data-i18n', 'Finish');
            nextStepButton.setAttribute('data-i18n-zh', '完成');
        } else {
            nextStepButton.setAttribute('data-i18n', 'Next');
            nextStepButton.setAttribute('data-i18n-zh', '下一頁');
        }
    
        if (languageToggle.textContent === '繁體中文') {
            nextStepButton.textContent = nextStepButton.getAttribute('data-i18n');
        } else {
            nextStepButton.textContent = nextStepButton.getAttribute('data-i18n-zh');
        }
    }
    
    function updateLanguageText() {
        elements.forEach(element => {
            if (languageToggle.textContent === '繁體中文') {
                if (element.hasAttribute('data-i18n')) {
                    element.textContent = element.getAttribute('data-i18n');
                }
            } else {
                if (element.hasAttribute('data-i18n-zh')) {
                    element.textContent = element.getAttribute('data-i18n-zh');
                }
            }
        });
    }
    
    function highlightCurrentStep() {
        const currentStepElement = steps[currentStep];
        const targetSelector = getTargetSelector(currentStep);
    
        if (targetSelector) {
            const targetElements = document.querySelectorAll(targetSelector);
            if (targetElements.length > 0) {
                let minLeft = Infinity, minTop = Infinity, maxRight = -Infinity, maxBottom = -Infinity;
    
                targetElements.forEach(elem => {
                    const rect = elem.getBoundingClientRect();
                    if (rect.left < minLeft) minLeft = rect.left;
                    if (rect.top < minTop) minTop = rect.top;
                    if (rect.right > maxRight) maxRight = rect.right;
                    if (rect.bottom > maxBottom) maxBottom = rect.bottom;
                });
    
                const padding = 10;
                const width = maxRight - minLeft + padding * 2;
                const height = maxBottom - minTop + padding * 2;
                const left = minLeft - padding;
                const top = minTop - padding;
    
                highlightBox.style.display = 'block';
                highlightBox.style.width = `${width}px`;
                highlightBox.style.height = `${height}px`;
                highlightBox.style.left = `${left}px`;
                highlightBox.style.top = `${top}px`;
                tutorialOverlay.classList.add('active');
            } else {
                removeHighlight();
            }
        } else {
            removeHighlight();
        }
    }
    
    window.addEventListener('resize', () => {
        if (tutorialOverlay.style.display === 'flex') {
            highlightCurrentStep();
        }
    });
    
    function removeHighlight() {
        highlightBox.style.display = 'none';
        tutorialOverlay.classList.remove('active');
    }
    
    function getTargetSelector(currentStep) {
        switch(currentStep) {
            case 0: return null;
            case 1: return '#controls .aspectRatioButtons';
            case 2: return '#aov';
            case 3: return '#verticalDiagonalAOV';
            case 4: return '#altitudeFOVMeasurements';
            case 5: return '.toggle-building';
            case 6: return '#additionalControls';
            case 7: return '#viewControls';
            case 8: return '#languageToggle';
            case 9: return null;
            default: return null;
        }
    }
    
    function updateTutorialTranslation() {
        updateLanguageText();
        highlightCurrentStep();
    }
    
    </script>
    
</body>
</html>
